% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/density.R
\name{dlba_gpu}
\alias{dlba_gpu}
\alias{n1PDF}
\title{Calculating Two-accumulator LBA Densities Using PDA Method}
\usage{
dlba_gpu(data, nsim = 1e+05, b = 1, A = 0.5, mean_v = c(2.4, 1.6),
  sd_v = c1, t0 = 0.5, nThread = 32)

n1PDF(x, nsim = 1024, b = 1, A = 0.5, mean_v = c(2.4, 1.6),
  sd_v = c(1, 1), t0 = 0.5, nthread = 64, debug = FALSE)
}
\arguments{
\item{data}{a data frame. Its 1st column must be RT and the 2nd
column must be R with level 1 and 2. The column names must be c('RT', 'R').
data for n1PDF is a vector.}

\item{nsim}{number of simulations, passed to internal rlba_gpu. The default 
is 1e5.}

\item{b}{threshold. Default is 1.}

\item{A}{starting point upper bound}

\item{mean_v}{mean drift rate. This must be a two-element vector.}

\item{sd_v}{standard deviation of drift rate. This must be a two-element 
vector.}

\item{t0}{non-decision time}

\item{nThread}{number of threads launched in GPU. Default is 32. Max is 1024.}
}
\value{
Likelihood.
}
\description{
This is the density function of the cannoical 2-accumualtor LBA model, 
sampling drift rates from the truncated normal distribution. The function
uses probability density approximation to estimate likelihood.
}
\examples{
## Use either rlba_gpu in 'gpda' or rLBA in 'rtdists' to generate LBA random
## observations. 'rtdists' uses c(rt, response) as column names, so I change
## it to our standard c('RT', 'R') 
## dat1 <- rlba_gpu(n, nThreads=1024); dplyr::tbl_df(dat1)
n <- 1e2
dat1 <- rtdists::rLBA(n, A=.5, b=1, mean_v=c(2.4, 1.6), sd_v=1, t0=.5, 
silent=T); 
names(dat1) <- c("RT","R")

## Get the densities with dlba_gpu
den3 <- dlba_gpu(dat1, nsim=2e5, nThread=32)

## Check den3 against n1PDF in 'lba' package and dLBA in 'rtdists' package
den.c <- as.vector(lba::n1PDF(dat1[dat1$R==1, "RT"], A=0.5, b=1, 
                   mean_v=c(2.4,1.6), sd_v=1, t0=0.5))
den.e <- as.vector(lba::n1PDF(dat1[dat1$R==2, "RT"], A=0.5, b=1, 
                   mean_v=c(1.6,2.4), sd_v=1, t0=0.5))
## Bind densities with RT, for plotting                  
den2.c <- data.frame(RT=dat1[dat1$R==1, "RT"], D=den.c)
den2.e <- data.frame(RT=dat1[dat1$R==2, "RT"], D=den.e)
den2 <- rbind(den2.c,den2.e)  ## den2 from 'lba' package

## den1 from 'rtdists' package
den1 <- rtdists::dLBA(dat1$RT, dat1$R, A=.5, b=1, mean_v=c(2.4,1.6), sd_v=1, 
     t0=.5, silent=T)
     
## Again bind data with densities       
den1 <- data.frame(RT=dat1$RT, R=dat1$R, D=den1); 
den1.c <- den1[den1$R==1,"D"]
den1.e <- den1[den1$R==2,"D"]

## Verify the 'lba' and 'rtdists' produce identical densities
all.equal(den.c, den1.c)
all.equal(den.e, den1.e)

## Calculate densities, using dlba_gpu.  Call it den3
den3 <- dlba_gpu(dat1, nsim=2e5, nThread=32)

## dlba_gpu return a 2-element list. First element is choice 1 (correct
## responses) and 2nd element is choice 2 (error responses). 
den3.c <- data.frame(RT=dat1[dat1$R==1, "RT"], D=den3$C1[,2])
den3.e <- data.frame(RT=dat1[dat1$R==2, "RT"], D=den3$C2[,2])
den3 <- rbind(den3.c,den3.e)

## Plot the densities calculated from three different packages, separately,
par(mfrow=c(1,3))
plot(den1$RT, den1$D)
plot(den2$RT, den2$D, pch=2, col="red")
plot(den3$RT, den3$D, pch=3, col="darkgreen")

## and together
par(mfrow=c(1,1))
plot(den1$RT, den1$D)
points(den2$RT, den2$D, pch=2, col="red")
points(den3$RT, den3$D, pch=3, col="darkgreen")

## n1PDF examples

data <- seq(0, 1, length.out = 10)
gpda::n1PDF(data)

## Test an unreasonable parameter vector ----
gpda::n1PDF(10, b=3.04, A=1.76, mean_v = c(2.79, -7.04), sd_v=c(1, 1), 
 t0=0.35)
 
## Test a safe parameter vector  
n <- 100
A <- .5; b <- 1; t0 <- .5
mean_v <- c(2.4, 1.6)
sd_v <- c(1,1)

## You can test an unreasonable parameter vector, too.
## But note that this set won't produce error RTs.  
# n <- 100
# A <- 1.76; b <- 3.04; t0 <- .35
# mean_v <- c(2.79, -7.04)
# sd_v <- c(1,1)

dat1 <- rtdists::rLBA(n, A=A, b=b, mean_v=mean_v, sd_v=sd_v, t0=t0, silent=T); 
             
names(dat1) <- c("RT","R")
datc1 <- dat1[dat1$R==1, "RT"]
date1 <- dat1[dat1$R==2, "RT"]
str(dat1); str(datc1); str(date1)

## Use lba, cpda and gpda package
denc1 <- as.vector(lba::n1PDF(datc1, A=A, b=b, 
         mean_v=mean_v, sd_v=sd_v, t0=t0))
dene1 <- as.vector(lba::n1PDF(date1, A=A, b=b, 
         mean_v=c(mean_v[2], mean_v[1]), sd_v=sd_v, t0=t0))
denc2 <- gpda::n1PDF(datc1, nsim=1e5, A=A, b=b, 
         mean_v=mean_v, sd_v=sd_v, t0=t0)
dene2 <- gpda::n1PDF(date1, nsim=1e5, A=A, b=b, 
         mean_v=c(mean_v[2], mean_v[1]), sd_v=sd_v, t0=t0)
denc3 <- cpda::n1PDF(datc1, nsim=1e5, A=A, b=b, 
         mean_v=mean_v, sd_v=sd_v, t0=t0)
dene3 <- cpda::n1PDF(date1, nsim=1e5, A=A, b=b, 
         mean_v=c(mean_v[2], mean_v[1]), sd_v=sd_v, t0=t0)
         
## First, plot correct RTs
plot(datc1, denc1)
points(datc1, denc2, col="grey")
points(datc1, denc3, col="lightblue")
## Then error RTs
points(date1, dene1, pch=2)
points(date1, dene2, pch=2, col="grey")
points(date1, dene3, pch=2, col="lightblue")
}
\references{
Holmes, W. (2015). A practical guide to the Probability Density
Approximation (PDA) with improved implementation and error characterization.
\emph{Journal of Mathematical Psychology}, \bold{68-69}, 13--24,
doi: http://dx.doi.org/10.1016/j.jmp.2015.08.006.
}
